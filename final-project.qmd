---
title: "Final Project"
subtitle: "Data Science for Public Policy"
author: "Madeleine Adelson, Stephanie Jamilla, Jamie Jelly Murtha"
format: 
  html:
    code-line-numbers: true
    body-width: 1600px
embed-resources: true
editor_options: 
  chunk_output_type: console
execute: 
  warning: false
urlcolor: blue
toc: true
---

# About This Project
Climate Central's UHI index values (in Â°F) are "estimates of how much the urban built environment boosts temperatures. In other words, the UHI index is an estimate of the additional heat that local land use factors contribute to urban areas."
Stephanie 12/10 - We'll need to change the above blurb based on what temperature data we use

# Setup

Loading packages:
```{r}
#| label: "Packages"
#| output: false

library(dotenv)
library(tidyverse)
library(ggplot2)
library(sf)
library(tidycensus)
library(stringr)
library(magrittr)
library(jsonlite)
library(httr)
library(tidymodels)
library(knitr)
library(kableExtra)
library(data.table)
library(patchwork)

# Clone the private github repository for this assignment using SSH link:
# git@github.com:stejamilla/final-project.git

# do not use scientific notation
options(scipen = 999)

```


# Exploring the Data

## Cleaning DC Land Cover Data

JAMIE 12/12: I took out our removal of all vars containing "_ac" because I needed these land variables for the metrics - we can remove them later below.

Loading data from Open Data DC:
```{r}
#| label: "Tree Canopy & ward data"

# Loading Urban Tree Canopy by Census Block Group (2020) data
landcover <- read_sf(paste0("data/Urban_Tree_Canopy",
                            "_by_Census_Block_Group_in_2020.shp")) |>
  rename(block_group = GEOID) |>
  mutate(block_group = as.character(block_group)) |>
  mutate(OBJECTID = as.character(OBJECTID)) |>
  rename_all(tolower) |>
  relocate(block_group, .after = objectid) |>
  # Converting UHI to Fahrenheit
  mutate(uhi = (uhi*(9/5) + 32))

# Loading DC Ward data from Urban Tree Canopy by Ward (2020)
wards <- read_sf("data/Urban_Tree_Canopy_by_Ward_in_2020.shp") |>
  rename_all(tolower) |>
  select(ward) |>
  st_transform(crs = st_crs(landcover))

```

Create key with Urban Tree Canopy data column descriptions and clean up:
```{r}
#| label: "Landcover key"

landcover_key <- read_csv("data/Urban_Tree_Canopy_Descriptions.csv",
                          col_names = FALSE) |>
  mutate(X1 = str_remove_all(X1, "\\( type:.*alias:|, length:.*| \\)")) |>
  separate(col = X1,
           into = c("field", "description"),
           sep = " ",
           extra = "merge") |>
  mutate(field = tolower(field))

```

Categorizing each block group into their respective ward:
```{r}
#| label: "Spatial join landcover and wards"

# Spatial join so that each block group is assigned a ward based on majority
# area of a block group within a ward
landcover <- st_join(landcover, wards, largest = TRUE)

# Mapping the overlapping wards & block groups
ggplot() +
  geom_sf(data = landcover,
          aes(fill = ward))
  

```
STEPHANIE 12/13 - this code says that if a ward intersects with a blockgroup, then classify that block group as a ward. For block groups that overlap multiple wards, it returns the ward that the block group overlaps with the most area (that's the argument largest = TRUE)

## Exploring Census Demographic Data

Load ACS 5-yr 2016-2020 variables:
```{r}
#| label: "ACS variable list for exploration"

acs_variables <- load_variables(2020, "acs5") |>
  filter(geography == "block group")

```


JAMIE 12/12 - I took out the category vars, let me know if anybody wants to add back in! I think the total measure would just give us the total line from the table that breaks down all income levels (for example, see the total line here: https://data.census.gov/table/ACSDT5Y2021.B19001?q=B19001). I added the median var below.
MADELEINE 12/14: good catch about the table totals! Working on imputation so we can use median

* Also prob don't need both total and median property values - just wanted to look at both
JAMIE 12/12 - Agreed, and here too, I don't think the total line would be super helpful (see total line here: https://data.census.gov/table?q=B25075) - I removed it to avoid confusion, hope that's ok! MADELEINE 12/14: yes!

* I believe the race categories I included should sum to the total population, but will test this
JAMIE 12/12 - I think based on my reading of the Census methodologies, they normally warn that they don't sum because of estimation and error at each level. But I think this would only a problem if we're trying to sum them and use the total. 

* I'm not sure what "total educational attainment" looks like - will do some testing there too. If it's hard to interpret or not in a useful format, we can use the categorical education variables (would probably want to consolidate them into fewer categories like HS or less, some college, BA+)
JAMIE 12/12 - Here too, normally this total line is just the sum of all individuals, just to provide a total line in the table for users who only access that table and need a sum (For example it would just represent the total line in this table: https://data.census.gov/table/ACSDT1Y2023.B15003?q=B15003). As I mentioned above re: race sums, they probably won't sum exactly.

* It occurs to me we may need to choose baseline categories for any categorical variables we include and leave those out? Not sure if that is only a requirement for line and linear regression?
JAMIE 12/12 - Good point! I'm adding stuff in below without factoring that in for now, but I think we def need to determine if we need to deal with this!
STEPHANIE 12/13 - I'm not too concerned about this because we've never had to address categorical variables in the assignments. We can do something like "step_dummy()" if we want to recode a categorical variable into a dummy instead.

### Loading Census demographic data via API

JAMIE 12/12 - Unfortunately I think we have to code -66666s as NAs. See here: http://bit.ly/3DnlfIh
"-666666666: The estimate could not be computed because there were an insufficient number of sample observations...For a 5-year median estimate, the margin of error associated with a median was larger than the median itself." I'm going to take out the code turning them to 0s and put in my code converting them to NAs - let me know if you guys disagree. This starts to get into the MOE issues Professor Williams was talking about...could become a problem...

MADELEINE 12/14: I imputed most of the missing data using tract-level data below. I then filled in the remaining observations (where there was also no data for the tract) using wards, after we merge landcover and acs_data.

JAMIE 12/12 - We have some duplicative vars but leaving them in here. I think we can remove at step_rm to keep it clean.

```{r}
#| label: "Load ACS data"


# Secure Census API key (from .env file) for use in Census API call
load_dot_env()
credential <- Sys.getenv("census_api_key")

# Create url for API call
url <- str_glue(paste0("https://api.census.gov/data/2020/acs/acs5?get=",
             # Description of data point
             "NAME,",
             # TOTAL POPULATION ESTIMATE
             "B01003_001E,",
             # TOTAL POPULATION BY RACE - WHITE ALONE
             "B02001_002E,",
             # TOTAL POPULATION BY RACE - BLACK OR AFR AMER ALONE
             "B02001_003E,",
             # TOTAL POPULATION BY RACE - AMER IND AND AK NAT ALONE
             "B02001_004E,",
             # TOTAL POPULATION BY RACE - ASIAN ALONE
             "B02001_005E,",
             # TOTAL POPULATION BY RACE - NAT HAW OR PAC ISL ALONE
             "B02001_006E,",
             # TOTAL POPULATION BY RACE - OTHER ALONE + TWO OR MORE RACES
             "B02001_008E,",
             # TOTAL HISPANIC OR LATINO
             "B03003_003E,",
             # TOTAL POP WITH DOCTORATE DEGREE
             "B15003_025E,",
             # TOTAL POP WITH PROFESSIONAL SCHOOL DEGREE
             "B15003_024E,",
             # TOTAL POP WITH MASTER'S DEGREE
             "B15003_023E,",
             # TOTAL POP WITH BACHELORS DEGREE
             "B15003_022E,",
             # TOTAL POP WITH ASSOCIATES DEGREE
             "B15003_021E,",
             # TOTAL POP WITH REGULAR HIGH SCHOOL DIPLOMA
             "B15003_017E,",
             # TOTAL POP WITH GED OR ALTERNATIVE CREDENTIAL
             "B15003_018E,",
             # MEDIAN HH INCOME IN PAST 12 MOS
             "B19013_001E,",
             # TOTAL HOUSING UNITS
             "B25002_001E,",
             # TOTAL OCCUPIED HOUSING UNITS
             "B25002_002E,",
             # TOTAL VACANT HOUSING UNITS
             "B25002_003E,",
             # MEDIAN PROPERTY VALUE
             "B25077_001E,",
             # GROSS RENT AS A % OF HH INCOME IN PAST 12 MO -
             # TOTAL
             "B25070_001E,",
             # GROSS RENT AS A % OF HH INCOME IN PAST 12 MO -
             # 30 TO 34.9 %
             "B25070_007E,",
             # GROSS RENT AS A % OF HH INCOME IN PAST 12 MO -
             # 35 TO 39.9 %
             "B25070_008E,",
             # GROSS RENT AS A % OF HH INCOME IN PAST 12 MO -
             # 40 TO 49.9 %
             "B25070_009E,",
             # GROSS RENT AS A % OF HH INCOME IN PAST 12 MO -
             # 50 % or more
             "B25070_010E",
             # Limit to block-group-level data for DC
             "&for=block%20group:*&for=tract:*&in=state:11&in=county:001"))

# Use url to request data from API
acs_json <- GET(url = url)

# Check call status
http_status(acs_json)

# Save API JSON response as text
acs_json <- content(acs_json, as = "text")

# Save JSON as character matrix
acs_matrix <- fromJSON(acs_json)

# Convert matrix to tibble
acs_data <- as_tibble(acs_matrix[2:nrow(acs_matrix), ],
                      .name_repair = "minimal")

# Add variable names to tibble
names(acs_data) <- acs_matrix[1, ] |>
  str_replace(" ", "_")

```

Labeling and cleaning ACS variables:
```{r}
#| label: "Cleaning ACS data"

# Clean up ACS data
acs_data <- acs_data |>
  # Meaningful variable names
  rename(total_pop = B01003_001E,
         race_white = B02001_002E,
         race_black = B02001_003E,
         race_ai_an = B02001_004E,
         race_asian = B02001_005E,
         race_nh_pi = B02001_006E,
         race_oth_mult = B02001_008E,
         race_eth_hisp = B03003_003E,
         ed_doct = B15003_025E,
         ed_prof_deg = B15003_024E,
         ed_master = B15003_023E,
         ed_bach = B15003_022E,
         ed_assoc = B15003_021E,
         ed_ged = B15003_018E,
         ed_reg_hsd = B15003_017E,
         med_hhi = B19013_001E,
         med_prop_val = B25077_001E,
         rent_burden_tot = B25070_001E,
         rent_burden_30_34 = B25070_007E,
         rent_burden_35_39 = B25070_008E,
         rent_burden_40_49 = B25070_009E,
         rent_burden_50plus = B25070_010E,
         total_hous_units = B25002_001E,
         vac_units = B25002_003E,
         occ_units = B25002_002E,
         block_group_temp = block_group) |>
  # Create block_group column to use for combining this with the other datasets
  mutate(block_group = paste(state,
                             county, 
                             tract, 
                             block_group_temp,
                             sep = "")) |>
  # Convert Census variables to numeric
  mutate_at(vars(total_pop:rent_burden_50plus), as.numeric) |>
  rename_all(tolower) |>
  relocate(block_group, .before = name)


# Convert rent burden variables into a percentage of rent burdened households,
# then dropping original rent burden vars
acs_data <- acs_data |> 
  mutate(
    rent_burden_sum = 
      rent_burden_30_34 + 
       rent_burden_35_39 + 
       rent_burden_40_49 + 
       rent_burden_50plus
    ) |>
  mutate(
    rent_burden_pct = (rent_burden_sum / rent_burden_tot)
    ) |>
  select(-c(rent_burden_30_34, 
            rent_burden_35_39, 
            rent_burden_40_49, 
            rent_burden_50plus,
            rent_burden_tot,
            rent_burden_sum)
         )
```

### Data Imputation Part 1

IMPUTATION
The imputation logic works as follows:
1) If data is missing at the block group level, use the mean for that block group's census tract.

2) If data is still missing at the census tract level, use the mean for that census tract's ward. (This happens further down in the code.)

This method is imperfect for two reasons:
1) Imputed values at the census tract level feed into imputation at the ward level. For instance, say a ward is made up of 4 census tracts and each tract has 4 block groups. Initially, only 2/4 tracts have complete data. After imputing at the tract level, 3/4 are complete. When we go to impute the data for the final tract, that calculation will include the values we imputed for the other missing tract. I don't think this is that big of a deal, especially because the numbers of values that need to be imputed at the ward level is pretty small.

2) Median household income and median property value are top- and bottom-coded (no one has an income less than $2,499 or greater than $250,000). The only way around this I can think of would be to choose one or more cutoffs as I did with the rent burden variable (for example, categorize income into "high income" and "low income"). I didn't do this because I wasn't sure what those cutoffs would be. I'm also not really sure how much it matters, since either way we can't capture the real high- and low-end incomes.
--
Imputation part 1: replace missing data points with tract-level data.

```{r}
#| label: "Imputation part 1"

# Create tract dataframe
tract_data <- acs_data |>
  mutate(med_hhi = if_else(
    med_hhi < 0, NA, med_hhi),
    med_prop_val = if_else(
      med_prop_val < 0, NA, med_prop_val)
  ) |>
  group_by(tract) |>
  summarize(
    rb_tract = mean(rent_burden_pct, na.rm = TRUE),
    hhi_tract = mean(med_hhi, na.rm = TRUE),
    propval_tract = mean(med_prop_val, na.rm = TRUE)
  )

# Replace missing data with tract data:
  
acs_data <- acs_data |>
  left_join(tract_data, by = "tract") |>
  # Rent burden
  mutate(rent_burden_pct = if_else(
    is.na(rent_burden_pct), rb_tract, rent_burden_pct)
  ) |>
  # Median HHI
  mutate(med_hhi = if_else(
    med_hhi < 0, hhi_tract, med_hhi)
  ) |>
  # Median property value
  mutate(med_prop_val = if_else(
    med_prop_val < 0, propval_tract, med_prop_val)
  )
         
         

```

JAMIE 12/12 - Note below the issues with the acs error codes
MADELEINE 12/14: Commenting this error codes section out since imputation removes them - but didn't want to delete this just yet. I moved the conversion to numeric up to the main census variable cleaning chunk.

```{r}

# Review frequency of ACS error coding (http://bit.ly/3DnlfIh)
#kable(acs_codes_summary <- acs_data |>
#  select(total_pop:med_rent_pct_inc) |>
#  summarise(across(everything(), list(
#    `sum-666666666` = ~sum(str_detect(., "-666666666"), na.rm=T),
#    `sum-999999999` = ~sum(str_detect(., "-999999999"), na.rm=T),
#    `sum-888888888` = ~sum(str_detect(., "-888888888"), na.rm=T),
#    `sum-222222222` = ~sum(str_detect(., "-222222222"), na.rm=T),
#    `sum-333333333` = ~sum(str_detect(., "-333333333"), na.rm=T),
#    `sum-555555555` = ~sum(str_detect(., "-555555555"), na.rm=T),
#    `sum*` = ~sum(. == "*", na.rm=T),
#    sumnull = ~sum(. == "null", na.rm=T),
#    sumNA = ~sum(is.na(.) == TRUE),
#    sumNA_Char = ~sum(. == "NA", na.rm=T)))) |>
#  pivot_longer(cols = everything(), 
#               names_to = c("colNames", ".value"),
#               names_sep="_sum") |>
#  filter(rowSums(across(where(is.numeric)))>0))

# Replace the codes with NA
#acs_data <- acs_data |> 
#  mutate(across(where(is.character), 
#                ~if_else(str_detect(.,
#  "-666666666|-999999999|-888888888|-222222222|-333333333|-555555555|null"),
#                         NA_character_, .))) 

```

# Creating the Final Dataset for Analysis

STEPHANIE 12/13 - I had to move this up and change the dataset from dc_train to landcover because we have to show how we determine the threshold before using mutate on it in the following code chunk.

## Deciding threshold for hotspot vs. not hotspot
Deciding the threshold for hot vs. not hot:
```{r}

# visualizing a cumulative histogram of counts of UHI values
landcover |>
  group_by(uhi) |>
  ggplot(aes(uhi)) +
  geom_histogram(aes(y = cumsum(..count..)))

# calculating frequency & cumulative frequency
heat_freq <- landcover |>
  count(uhi)

heat_freq$cumulative <- cumsum(heat_freq$n)

heat_freq |>
  filter(
    cumulative >= 285,
    cumulative <= 286) |>
  head()

# exploring other ways to generate a cutoff
heat_freq |> summarize(
  sd(uhi),
  mean(uhi)
)
# The standard deviation of UHI is 1.80
# The mean is 89.8
  # 1 SD above mean would be 91.6

heat_freq |>
  filter(uhi >= 91.6) |>
  count()
  
# 82 block groups have a UHI value at least one SD above the mean. I think this 
# might be a better metric to use than a 50th or 75th percentile ranking -
# I found that the temps at those percentiles are actually really close.

```

MADELEINE 12/14: I split up the join from the metrics because the ward-level imputation has to happen in between (after join, before metrics).

```{r}
#| label: "Create final dataset"

dc_full_data <- left_join(landcover, acs_data, by = "block_group") 

```

### Data Imputation Part 2
Imputation part 2: for any data points still missing after imputing on tract level, impute on ward level

```{r}
#| label: "Imputation - ward level"

# Create ward-level dataframe
ward_data <- dc_full_data |>
  group_by(ward) |>
  summarize(
    rb_ward = mean(rent_burden_pct, na.rm = TRUE),
    hhi_ward = mean(med_hhi, na.rm = TRUE),
    propval_ward = mean(med_prop_val, na.rm = TRUE)
  ) |>
  st_drop_geometry()

# Replace missing data with ward data:
# Rent burden
dc_full_data <- dc_full_data |>
  left_join(ward_data, by = "ward") |>
  mutate(
    rent_burden_pct = if_else(
      is.na(rb_tract), rb_ward, rent_burden_pct),
    med_hhi = if_else(
      is.na(hhi_tract), hhi_ward, med_hhi),
    med_prop_val = if_else(
      is.na(propval_tract), propval_ward, med_prop_val)
    )
  
# Drop columns no longer needed
dc_full_data <- dc_full_data |>
  select(-c(rb_tract, rb_ward, 
            hhi_tract, hhi_ward,
            propval_tract, propval_ward))

```


```{r}
#| label: "Create metrics"

dc_full_data <- dc_full_data|>
  mutate(
    # convert total acres to sq miles
    total_sq_mi = total_ac * 0.0015625,
    # convert water acres to sq miles
    water_sq_mi = wat_ac * 0.0015625,
    # calculate water share of total sq miles
    share_water_sq_mi = water_sq_mi / total_sq_mi,
    # calculate population density per square mile
    pop_dens_sq_mi = total_pop / total_sq_mi,
    # calculate population density per water sq mile
    pop_density_water_sq_mi = ifelse(
      water_sq_mi !=0, total_pop / water_sq_mi, 0),
    # calculate ratio of housing units to population
    hous_units_per_person = ifelse(
      total_hous_units != 0, total_hous_units / total_pop, 0),
    # calculate ratio of vacant units to all units
    vac_units_share = ifelse(
      total_hous_units != 0, vac_units / total_hous_units, 0),
    # calculate ratio of total income to median home value
    inc_home_val_ratio = med_hhi / med_prop_val,
    # create combined HS diploma or equivalent variable
    ed_comb_hsd = ed_reg_hsd + ed_ged,
    # create combined advanced post-undergraduate variable
    ed_comb_adv_deg = ed_doct + ed_prof_deg + ed_master,
    # calculate ratio of 25+ pop with HSD to total pop
    ed_hsd_ratio = ifelse(
      ed_comb_hsd !=0, ed_comb_hsd / total_pop, 0),
    # calculate ratio of 25+ pop with bachelor's degree to total pop
    ed_bach_ratio = ifelse(
      ed_bach != 0, ed_bach / total_pop, 0),
    # calculate ratio of 25+ pop with advanced post-bach degree to total pop
    ed_adv_ratio = ifelse(
      ed_comb_adv_deg != 0, ed_comb_adv_deg / total_pop, 0),
    # calculate pop share white
    race_white_ratio = ifelse(
      race_white != 0, race_white / total_pop, 0),
    # calculate pop share black or african american
    race_black_ratio = ifelse(
      race_black != 0, race_black / total_pop, 0),
    # calculate pop share american indian or alaska native
    race_ai_an_ratio = ifelse(
      race_ai_an!= 0, race_ai_an / total_pop, 0),
    # calculate pop share asian
    race_asian_ratio = ifelse(
      race_asian != 0, race_asian / total_pop, 0),
    # calculate pop share native hawaiian or pacific islander
    race_nh_pi_ratio = ifelse(
      race_nh_pi != 0, race_nh_pi / total_pop, 0),
    # calculate pop share two or more races
    race_oth_mult_ratio = ifelse(
      race_oth_mult != 0, race_oth_mult / total_pop, 0),
    # calculate pop share hispanic or latino
    race_eth_hisp_ratio = ifelse(
      race_eth_hisp != 0, race_eth_hisp / total_pop, 0),
    # calculate total non-white population
    race_poc = race_black + race_ai_an + race_asian + race_nh_pi + race_oth_mult,
    # calculate pop share non-white
    race_poc_ratio = ifelse(
      race_poc != 0, race_poc / total_pop, 0),
    # creating hotspot var for decision tree model
    hotspot = if_else(
      uhi >= 91.6, "hotspot", "not hotspot"),
    # remove factor from uhi var
    uhi = as.numeric(as.character(uhi))) |>
  relocate(c("block_group_temp", "tract"), .after = 2) |>
  # remove columns with only one unique value
  select(-objectid,
         -name,
         -state,
         -statefp,
         -county,
         -countyfp,
         -tractce,
         -blkgrpce,
         -namelsad,
         -mtfcc,
         -funcstat,
         -field,
         -shapearea,
         -shapelen) |>
  relocate(race_white_ratio:race_eth_hisp_ratio,
           .after = race_eth_hisp) |>
  relocate(ed_comb_hsd:ed_adv_ratio,
           .after = ed_ged) |>
  relocate(hous_units_per_person:inc_home_val_ratio,
           .after = med_prop_val) |>
  relocate(total_sq_mi:pop_density_water_sq_mi,
           .after = inc_home_val_ratio) |>
  relocate(total_pop:hotspot, .after = tract)

```

## Prepare the data for analysis (set seed & splitting)

JAMIE 12/12 - Changed the var names so that these are the splits we use for all models, not just decision tree

* Do we need an implementation set too?

STEPHANIE 12/13 - Aaron mentioned that we should make sure that when we split the data, that we should stratify the data by some geographic feature so that for example not all the block groups in a certain ward are only in the training data. Because then our model would only really work for that ward. Thus, the argument strata = ward.
* Concerning implementation data, I worry that since we only have a set of n = 571 that taking out a number would significantly affect our model. Maybe we can just do a set of 10 data points for the implementation data like we did in Assignment 7, but we'd have to randomize which ten are taken out (which we didn't do in assignment 7, we sliced the data by where observations were located in the dataset)


```{r}

# Set seed
set.seed(20241202)

# Split sample and create training and testing datasets
dc_split <- initial_split(data = dc_full_data, strata = ward, prop = 0.8)
dc_train <- training(x = dc_split) 
dc_test <- testing(x = dc_split)

```

# Initial EDA

## Review summary statistics

JAMIE 12/12 - Added summary stats table here

```{r}

# Review summary statistics
kable(dc_train_summary <- as_tibble(dc_train |>
                                      select(where(is.numeric)) |>
                                      lapply(summary) |>
                                      lapply(`length<-`, 6)) |>
        mutate(measure = c("Min", "Q1", "Median", "Mean", "Q3", "Max")) |>
        mutate(across(everything(), as.vector)) |>
        pivot_longer(-measure) |>
        pivot_wider(id_cols = "name",
                    names_from = "measure",
                    values_from = "value"))

```

## Exploration of some of the continuous variables

JAMIE 12/12 - when we run the below viz we have a warning message that 56 rows were removed.

* I silenced the total ed attainment ggplot per by above note.

STEPHANIE 12/13 - concerning the rows being removed, I think that's fine. I think that's happened with me for other visualizations before.
* Concerning the ed attainment, I'm getting a thing that "educ_total" doesn't exist...so I'm not sure what's happening here
JAMIE 12/13 - I removed the var that went into educ_total bc it's just the total line in the education table. So basically if we want to use a data viz here we need to use the categorical vars.


```{r}

# Median household income, continuous
dc_train |>
  ggplot() +
  geom_histogram(aes(x = as.numeric(med_hhi))
  )

# Total educational attainment
#dc_train |>
#  ggplot() +
#  geom_histogram(aes(x = as.numeric(educ_total))
#  )
# Still not sure how to interpret this one. Might be worth going back to the categories

```

## Exploring temperature in relation to other variables

JAME 12/12 - I fixed this - I guess we have to left_join with the sf df in the first position in left_join(), so that we join the non-sf df onto the sf df and it stays sf. BUT do we have to st_transform() since the crs is not 4326?

STEPHANIE 12/13 - It doesn't matter that the CRS isn't 4326 for mapping purposes - the main concern with CRS is that it has to be the same between two spatial datasets if you're going to do something like join the two. 
I'm also realizing that we probably shouldn't do a map here with dc_train because this map shows which block groups are in the training data (vs. the testing data) since you can see which block groups are excluded from the map...so this may be a form of data leakage. I'm going to instead use the dc_full_data dataset.

```{r}

dc_full_data |> ggplot() +
  geom_sf(
    mapping = aes(fill = uhi),
    color = "#400001"
    ) +
    scale_fill_gradient(
    low = "#ffffff",
    high = "#be2b25"
    ) +
  labs(
    title = "Average evening temperature, 2018",
    fill = "Temperature (degrees F)"
  ) +
  theme_void()

```

Temperature & population:
```{r}

# Total population
dc_train |>
  ggplot(aes(x = total_pop, y = uhi, color = hotspot)) +
  geom_point(alpha = 0.5) +
  theme_minimal()

# Population density
dc_train |>
  ggplot(aes(x = pop_dens_sq_mi, y = uhi, color = hotspot)) +
  geom_point(alpha = 0.5) +
  theme_minimal()

# Non-white population density
dc_train |>
  ggplot(aes(x = race_poc_ratio, y = uhi, color = hotspot)) +
  geom_point(alpha = 0.5) +
  theme_minimal()

```

Temperature & income/education
```{r}

# Median household income
dc_train |>
  ggplot(aes(x = med_hhi, y = uhi, color = hotspot)) +
  geom_point(alpha = 0.5) +
  theme_minimal()

# Ratio of bachelors degrees
dc_train |>
  ggplot(aes(x = ed_bach_ratio, y = uhi, color = hotspot)) +
  geom_point(alpha = 0.5) +
  theme_minimal()

```

Temperature & landcover
```{r}

# Comparing with percentage of non-canopy vegetation
dc_train |>
  ggplot(aes(x = veg_pct, y = uhi, color = hotspot)) +
  geom_point(alpha = 0.5) +
  theme_minimal()

# Comparing with percentage area of urban tree canopy
dc_train |>
  ggplot(aes(x = utc_pct, y = uhi, color = hotspot)) +
  geom_point(alpha = 0.5) +
  theme_minimal()

# Comparing with percentage area of impervious surfaces (e.g., roads, parking
# lots, etc.)
dc_train |>
  ggplot(aes(x = to_ia_pct, y = uhi, color = hotspot)) +
  geom_point(alpha = 0.5) +
  theme_minimal()

```

STEPHANIE 12/13 - The graphs that compare UHI with percentage area of urban tree canopy and of impervious surfaces seems quite compelling. This makes sense, and it's interesting to notice how not a lot of the demographic stuff doesn't seem to show up in EDA but the landcover stuff seem like promising predictors.

## Preparation for Modeling
STEPHANIE 12/13 - I added "-tract" and "-ward" to remove more geographic indicators that likely would affect the model, since that otherwise would've been a main predictor of a hotspot

JAMIE 12/12 - Do we want folds? added here. Not using folds does not make the lm rank deficient model warning go away.
STEPHANIE 12/13 - I think yes, we'll have to use it, especially for hyper parameter tuning. My main issue with folding at this point is that I think we need to remove all the variables we don't want from dc_train first and then get do folding so that the folding process doesn't take them into account. So I think we should take out the variables from dc_train before the lm and rf models (using select rather than step_rm) and then do the folding.
JAMIE 12/13 - Relocated these steps per discussion.

MADELEINE 12/14 - should hotspot be kept in here? there is a comment saying "remove duplicative hotspot", but then the next code chunk seems to need it

STEPHANIE 12/15 - that's a good point, Madeleine; we'll have to remove it for lm and rf but need to keep it in for decision tree

```{r}

# Prep the dataset for modeling
dc_train <- dc_train |>
  st_drop_geometry() |>
  select(
    # remove identifying vars
    -block_group,
    -intptlat,
    -intptlon,
    -gis_id,
    -globalid, gid,
    -tract,
    -ward,
    -block_group_temp,
    # remove raw total pop var (custom pop density and other pop proportion
    # vars remain)
    -total_pop,
    # remove raw race vars (custom proportion vars remain)
    -race_white,
    -race_black,
    -race_ai_an,
    -race_asian,
    -race_nh_pi,
    -race_oth_mult,
    -race_eth_hisp,
    # remove raw ed vars (custom proportion vars remain)
    -ed_doct,
    -ed_prof_deg,
    -ed_master,
    -ed_bach,
    -ed_assoc,
    -ed_reg_hsd,
    -ed_ged,
    -ed_comb_hsd,
    -ed_comb_adv_deg,
    # remove duplicative housing data (custom proportion vars and pct var
    # remain)
    -total_hous_units,
    -occ_units,
    -vac_units,
    # remove duplicative land data (custom proportion / "pct" vars remain)
    -ends_with("_ac"),
    -total_sq_mi,
    -water_sq_mi,
    -wtr_pct,
    -aland,
    -awater,
    -utcac0620,
    -utcac1120,
    -utcac1520,
    -utcpct0620,
    -utcpct1120,
    -utc_pct_06,
    -utc_pct_11,
    -utc_pct_15,
    # remove pop_density_water_sq_mi due to INF value for most records 
    -pop_density_water_sq_mi) 

# V-fold cross validation with 10 folds
dc_folds <- vfold_cv(data = dc_train, v = 10)

```

# Decision Tree

## Modeling

```{r}

dt_recipe <- recipe(formula = hotspot ~ ., data = dc_train) |>
  # remove uhi var to avoid duplication of data from hotspot
  step_rm(uhi) |>
  themis::step_downsample(hotspot) |> 
  step_nzv(all_numeric_predictors())

dt_model <- decision_tree() |>
  set_engine(engine = "rpart") |>
  set_mode(mode = "classification")

dt_workflow <- workflow() |>
  add_recipe(dt_recipe) |>
  add_model(dt_model)
  
dt_fitting <- dt_workflow |>
  fit(data = dc_train)

rpart.plot::rpart.plot(x = dt_fitting$fit$fit$fit,
                       roundint = FALSE)

```
STEPHANIE 12/15 - Retaining comments for write-up in case we want to utilize them:

Note on results:
I think we have an interesting model. The first decision point is whether the percentage of the block group that's covered by tree canopy; if it's greater or equal to 23% then it's not a hotspot. If it is less than 23%, then you check how suitable the block group is for tree planting "based on a weighted formula that includes all planting prioritization categories." If the score is less than 7, then it's a not hotspot. If it's greater than or equal to seven, you check the percent of total area that's covered by all combined impervious surfaces. If the percentage is less than 66%, then it's not a hotspot. If it's greater than or equal to 66%, then the final check is whether the number of housing units per person is less than 0.74. If it's greater than or equal to 0.75, then it's not a hotspot. If it is less than 0.74 then it is a hotspot.

Note on methods:
STEPHANIE 12/13 - I've decided to keep in downsampling because I think it's useful. For reference, down-sampling "randomly subset all the classes in the training set so that their class frequencies match the least prevalent class. For example, suppose that 80% of the training set samples are the first class and the remaining 20% are in the second class. Down-sampling would randomly sample the first class to be the same size as the second class (so that only 40% of the total training set is used to fit the model)."

## Visualizing Important Variables

STEPHANIE 12/13 - Using dc_full_data as the dataset since it's possible we may accidentally do data leakage when mapping dc_train because we'll notice which block groups were excluded.

```{r fig.width = 8, fig.height = 8}

canopy_map <- dc_full_data |> ggplot() +
  geom_sf(aes(fill = utc_pct)) +
    scale_fill_gradient(
    low = "#fcbc32",
    high = "#4e974b"
    ) +
  theme_minimal() +
  labs(
    title = "Percentage of tree canopy",
    subtitle = "by Block Group",
    fill = "Percent Area",
    caption = "Open Data DC (2020)"
  )

planting_map <- dc_full_data |> ggplot() +
  geom_sf(aes(fill = overall)) +
    scale_fill_gradient(
    low = "#b8f29d",
    high = "#c62336"
    ) +
  theme_minimal() +
  labs(
    title = "Tree planting suitability score",
    subtitle = "by Block Group",
    fill = "Score",
    caption = "Open Data DC (2020)"
  )

impervious_map <- dc_full_data |> ggplot() +
  geom_sf(aes(fill = to_ia_pct)) +
    scale_fill_gradient(
    low = "#28292b",
    high = "#f8a700"
    ) +
  theme_minimal() +
  labs(
    title = "Percentage covered by impervious surfaces",
    subtitle = "by Block Group",
    fill = "Percent Area",
    caption = "Open Data DC (2020)"
  )

housing_map <- dc_full_data |> ggplot() +
  geom_sf(aes(fill = hous_units_per_person)) +
    scale_fill_gradient(
    low = "#d893aa",
    high = "#1dc664"
    ) +
  theme_minimal() +
  labs(
    title = "Housing units per person",
    subtitle = "by Block Group",
    fill = "# Housing Units",
    caption = "ACS 2016-2020"
  )

canopy_map + planting_map + impervious_map + housing_map

```

## Evaluating the Model

STEPHANIE 12/15 - Adding this evaluation in since we need to assess the decision tree model on its own (can't really compare it to rf and lm since they have different outcome variables).

### Creating predictions

```{r}
# Ensuring the testing dataset has the same variables as the training dataset
dc_test <- dc_test |>
  st_drop_geometry() |>
  select(
    # remove identifying vars
    -block_group,
    -intptlat,
    -intptlon,
    -gis_id,
    -globalid, gid,
    -tract,
    -ward,
    -block_group_temp,
    # remove raw total pop var (custom pop density and other pop proportion
    # vars remain)
    -total_pop,
    # remove raw race vars (custom proportion vars remain)
    -race_white,
    -race_black,
    -race_ai_an,
    -race_asian,
    -race_nh_pi,
    -race_oth_mult,
    -race_eth_hisp,
    # remove raw ed vars (custom proportion vars remain)
    -ed_doct,
    -ed_prof_deg,
    -ed_master,
    -ed_bach,
    -ed_assoc,
    -ed_reg_hsd,
    -ed_ged,
    -ed_comb_hsd,
    -ed_comb_adv_deg,
    # remove duplicative housing data (custom proportion vars and pct var
    # remain)
    -total_hous_units,
    -occ_units,
    -vac_units,
    # remove duplicative land data (custom proportion / "pct" vars remain)
    -ends_with("_ac"),
    -total_sq_mi,
    -water_sq_mi,
    -wtr_pct,
    -aland,
    -awater,
    -utcac0620,
    -utcac1120,
    -utcac1520,
    -utcpct0620,
    -utcpct1120,
    -utc_pct_06,
    -utc_pct_11,
    -utc_pct_15,
    # remove pop_density_water_sq_mi due to INF value for most records 
    -pop_density_water_sq_mi) 

# Creating predictions dataset
dt_predictions <- bind_cols(
  dc_test,
  predict(object = dt_fitting, new_data = dc_test),
  predict(object = dt_fitting, new_data = dc_test, type = "prob")
) 

# Editing column names so it's readable
names(dt_predictions) <- names(dt_predictions) |>
  str_replace(" ", "_")

# Printing a few predictions
dt_predictions |>
  select(hotspot, .pred_class, .pred_hotspot, .pred_not_hotspot) |>
  print(n = 20)

```

### Creating confusion matrix
```{r}

dt_predictions$hotspot <- as.factor(dt_predictions$hotspot)

conf_mat(data = dt_predictions,
         truth = hotspot,
         estimate = .pred_class)

```

Calculating precision and recall/sensitivity:
```{r}

precision(data = predictions,
          truth = grade,
          estimate = .pred_class)

recall(data = predictions,
     truth = grade,
     estimate = .pred_class)

```


# Linear Regression

JAMIE 12/12 - Added recipe for lm and rf and added lm model and fit below. Having trouble with this major warning:
A | warning: prediction from rank-deficient fit; consider predict(., rankdeficient="NA")
Also, I experimented here with removing all the columns that seemed duplicative. I did not add this to the dt recipe for now. Let me know what you all think of removing these.

STEPHANIE 12/13 - The main issue are the columns that have NA values. We need to decide if we should remove those or if it's possible for us to do data imputation aka decide what those values should be.
I removed the identifying factor variables becuase I had to remove them earlier from dc_train.

```{r}

# Create recipe for use in linear regression and random forest models
# Create the recipe
dc_recipe <- recipe(formula = uhi ~ ., data = dc_train) |>
  # remove duplicative hotspot 
  step_rm(hotspot) |>
  # Removing predictors that have near zero variability
  step_nzv(all_predictors()) |>
  # Removing predictors that are highly correlated with others
  step_corr(all_predictors())

```

## Modelling

```{r}

d

# Linear regression model
dc_lm_model <- 
  linear_reg() |>
  set_mode(mode = "regression") |>
  set_engine(engine = "lm")

# Linear regression workflow
dc_lm_workflow <- 
  workflow() |>
  add_recipe(recipe = dc_recipe) |>
  add_model(spec = dc_lm_model)
  
unloadNamespace("Metrics")

# Fit the regression workflow
dc_lm_fit <-
  dc_lm_workflow |>
  fit_resamples(
    resamples = dc_folds,
    metrics = metric_set(rmse),
    control = control_resamples(save_workflow = TRUE))

```

# Random Forests

## Modelling 

### Hyperparameter Tuning

```{r}

dc_rf_model <- 
  rand_forest(
  trees = 200,
  mtry = tune(),
  min_n = tune()) |>
  set_mode(mode = "regression") |>
  set_engine(
    engine = "ranger", 
    importance = "impurity",
    num.threads = 4
  )

# Create a parameter grid
kable(dc_rf_grid <- grid_regular(mtry(range = c(1, 15)),
                                min_n(range = c(1, 15)),
                                levels = 5))

# Random forest workflow
dc_rf_workflow <- 
  workflow() |>
  add_recipe(dc_recipe) |>
  add_model(dc_rf_model)

# Creating a grid to show results of hyper parameter tuning
dc_rf_grid <- grid_regular(
  mtry(range = c(1, 15)),
  min_n(range = c(1, 15)),
  levels = 5
)

# Tuning the grid
rf_resamples <- tune_grid(
  dc_rf_workflow,
  resamples = dc_folds,
  grid = dc_rf_grid
)

# Showing the best hyperparameters
show_best(rf_resamples)

```

### Implementing best hyperparameters based on tuning

```{r}

# Filling in hyperparameters based on tuning
dc_rf_model <- rand_forest(
  trees = 200,
  mtry = #fill in based on the best resample,
  min_n = #fill in based on the best resample
) |>
  set_mode(mode = "regression") |>
  set_engine(
    engine = "ranger", 
    importance = "impurity",
    num.threads = 4
  )

# Random forest workflow
dc_rf_workflow <- 
  workflow() |>
  add_recipe(dc_recipe) |>
  add_model(dc_rf_model)

rf_resamples <- dc_rf_workflow |>
  fit_resamples(resamples = dc_folds)

rf_resamples |>
  collect_metrics(summarize = FALSE) |>
  filter(.metric == "rmse") |>
  print() |>
  ggplot(mapping = aes(x = id, y = .estimate, group = .metric)) +
  geom_point() +
  geom_line()

```

# Comparing Models
## Plot the RMSEs across each fit:

JAMIE 12/12 - Below is what I used in the assignment 07 hw to pull the metrics in the end, so pasted here and updated a bit. It renders!

```{r}

# Create a df with rmses for all models

# Extract rmses for rf approach
rf <- as_tibble(
  sapply(dc_rf_fit$.metrics, function(x) extract2(x, 1))) |>
  select(V1) |>
  rename(mtry = V1) |>
  bind_cols(as_tibble(
  sapply(dc_rf_fit$.metrics, function(x) extract2(x, 2)))) |>
  select(mtry, V1) |>
  rename(min_n = V1) |>
  bind_cols(as_tibble(
  sapply(dc_rf_fit$.metrics, function(x) extract2(x, 5)))) |>
  rename_all( ~ str_replace(., "V", "Fold0")) |>
  rename(Fold10 = Fold010) |>
  pivot_longer(cols = 3:12,
               names_to = "id",
               values_to = "rmse") |>
  mutate(model = "rf") |>
  select(id, mtry, min_n, model, rmse)

# Extract rmses for lm approaches
lm <- tibble(
  id = dc_lm_fit$id,
  lm = as_vector(sapply(dc_lm_fit$.metrics, function(x) extract2(x, 3)))) |>
  pivot_longer(cols = c("lm"),
               names_to = "model",
               values_to = "rmse") |>
  mutate(mtry = NA,
         min_n = NA) |>
  select(id, mtry, min_n, model, rmse)

# Create one df containing all rmses
fit_comps <- bind_rows(lm, rf)

# Plot the rmses
fit_comps |>
  ggplot(mapping = aes(x = model, y = rmse)) +
  geom_point() +
  labs(title = "RMSE of Linear Regression and Random Forest Models\n",
       subtitle = paste0("Prediction Model Evaluation for Washington, DC\n",
                         "Urban Heat Index (UHI)"),
       x = "Prediction Model",
       y = "RMSE")

# print average rmse per model
kable(avg_rmse <- tibble(
  model = c("lm", "rf"),
  rmse = c(mean(fit_comps$rmse[fit_comps$model=="lm"]),
           mean(fit_comps$rmse[fit_comps$model=="rf"]))) |>
    arrange(rmse))

```

## Estimate the out-of-sample error rate

JAMIE 12/13 - Added metrics work below

```{r}

library(Metrics)

# save best lm fit
best_lm_fit <- fit_best(dc_lm_fit, verbose = TRUE)

# make predictions using best fit
test_predictions <-
  dc_test |>
  select(uhi) |>
  rename(y = uhi) |>
  mutate(y = as.numeric(y)) |>
  mutate(y_hat = as.numeric(as_vector(predict(best_lm_fit, dc_test))))

# collect rf metrics
kable(rmse(actual = test_predictions$y, predicted = test_predictions$y_hat))

```

# Implement the Final Model

STEPHANIE 12/13 - Setting up the final code block for when we decide which model we should make predictions from. This probably won't render because the random forest model isn't working at the time I'm writing this (7pm) 

```{r}

pred_test <- bind_cols(
  dc_test,
  predict(object = extract_workflow(#fill in with fitted model either lm or rf), 
          new_data = dc_test)
)

select(pred_test, uhi, starts_with(".pred")) |>
  print(n = 20)

```

## Visualizing the most important predictors
```{r}

#insert the best fitted model |>
  extract_fit_parsnip() |>
  vip(num_features = 20) %>%
  .$data |>
  mutate(
    Importance = Importance / max(Importance),
    Variable = fct_reorder(.x = Importance, .f = Variable)
  ) |>
  ggplot(aes(Importance, Variable)) +
  geom_col()

```

STEPHANIE 12/13 - Then over here we should make some maps with the top ~3 variables as determined by the code chunk above
```{r}



```

# Sources

https://www.climatecentral.org/climate-matters/urban-heat-islands-2024

https://opendata.dc.gov/datasets/DCGIS::urban-tree-canopy-by-census-block-group-in-2020/about

Census ACS 5yr 2016 - 2020

https://www2.census.gov/programs-surveys/acs/tech_docs/accuracy/MultiyearACSAccuracyofData2020.pdf

http://bit.ly/3DnlfIh


